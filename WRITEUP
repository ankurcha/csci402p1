Title: Writeup for Project 2, Fall 2009

Date: 09/23/2009

Group Num 11: Name              Email               Student ID
              Ankur Chauhan     ankurcha@usc.edu    8478-1604-85
              Max Pflueger      pflueger@usc.edu    5888-2249-87
              Aneesha Mathew    aneesham@usc.edu    3976-3694-15

 vim:textwidth=75

I. Requirements:
    Part 1:
        
        For part 1 of the project we are required to implement the suite of
        system calls and exception handling defined in the project handout.
        This includes the implementations of the system calls as well as test
        cases showing that the system calls are both correct and safe.  Exec
        and Fork in particular will require additional underlying mechanisms to
        produce the correct behavior.

    Part 2:
        
        For part 2 of the project we are required to modify the existing code
        to support multiple processes, and multiple threads within a process.
        In order to achieve this we have to allocate system memory in such a
        way that virtual addresses may not match physical addresses (to support
        multiple processes that want the same address space).  We also have to
        provide a mechanism for creating multiple stacks within a single
        process and address space for the threads of that process.  This
        section is closely tied to the part 1 system calls Exec and Fork which
        will use the code from part 2, as in part 1, tests must be provided to
        ensure that part 2 code is behaving properly and is safe from malicious
        user programs.

    Part 3:
        
        For part 3 of the project we are required to adapt our hospital
        simulation from project 1 to run as a user process with our project 2
        code.  Everything that was previously implemented as a thread of the
        kernel in project 1, will now be a thread of the user process.  It
        should be possible to run multiple Hospitals simultaneously as separate
        user threads.  We should provide tests to show that all of this
        behavior is correct.

II. Assumptions:

    We assume:
        -Functions provided by NACHOS are generally bug free and perform as
         specified.
        -File system system calls are correct as provided.
        -Condition variable and Lock implementations will be identical to
         project 1.
        -Programs are provided with adequate stack space to avoid overflow
        -Physical memory is sufficiently large to accomidate all processes.
         (i.e. simulated physical memory size can be increased until it is 
         sufficient for all processes)

III. Design:

    Part 1:
        
        The system calls have been implemented as they were described in the
        student documentation. Synchronization of the lockTable, Condition
        variables Table and the process table has been delt with by using the
        Locks internally and this aspect is made transparent to the user.

        LockId CreateLock(name)
            This system call is used to create a new Lock. Each lock, as it is
            created is entered into the LocksTable and then the lock is
            referenced using the lockId as returned by this function. In case
            of a failure in the creation of the lock or failure to import the
            lock into the lockTable the system call would return -1 as the
            lockId.

        Acquire(LockId)
            This system call is used to acquire a lock that had been created by
            the user. In case the lock does not exist, this system call would
            just ignore the error, print out a message, "unable to find
            lock...".  Release(LockId) This system call is used to release a
            lock that is currently acquired by the thread.  In case, the lock
            is not in the lockTable or if the lock is not currently acquired by
            the thread, the error is printed on the screen when in debug mode.

        Release(LockId)
            This used 

        DestroyLock(LockId)
            This system call is used to delete the lock which had been
            previously created. In case there are other threads in the waiting
            queue, the lock is simply marked for deletion, the actual deletion
            would then happen all the threads have left the queue and the last
            thread also performs the release.  At this point it will check if
            it is the only thread on the queue and the lock is marked for
            deleting, it will remove the lock from the lockTable and also
            delete the Lock from memory.

        CVId CreateCondition(name)
            This system call is used to create a new Condition Variable. Each
            condition variable, as it is created is entered into the condition
            variables table - CVTable and then the condition variable is
            referenced using the CVId as returned by this call. In case of
            failure in the creation of the condition variable or failure to
            import the CV to the CVTable the system call returns -1.
        
        Wait(CVId, LockId)
            This is used to call Wait on a condition variable using the lock
            that is given as the second argument to this call. In case of any
            errors, either the lock is non existant or CVId is invalid or the
            lock used with the CVId is not the one for which the CV is being
            used or the Lock is not currently held by the current Thread, the
            program/kernel doesn't halt, instead it just displays the error and
            simply returns.

        Signal(CVId, LockId)
            This signal is used to send a signal to a condition Variable
            referenced using CVId. All the error conditions are same as that
            for Wait system call. It causes a single thread waiting on the
            condition variable to wake up.

        Broadcast(CVId, LockId)
            This system call is same as signal but instead of waking up just
            one thread waiting on the condition variable, it wakes up all the
            threads that are waiting on the condition variable. The error
            conditions are same as that mentioned for Wait() system call and
            are ignored and execution continues.

        Fork(VoidFunctionPtr)
            This system call is used to fork a new thread. When we call this
            function we get the virtual address of the function to be forked
            from the machine register(2). Then we first make a new thread. And
            we make the address space pointer point to the same address space
            as that of the spawning process. We then fork the kernel_thread
            function with the virtual address of the function to initialize the
            registers and allocate a new stack. This call also creates the
            required entries to the process table and the childThreads table of
            the address space associated with this thread.

        kernel_thread()
            This is a helper function for the fork system call. It does the
            following steps:
                1. Load the Reg with virtual address.
                2. Load the Next Reg with virtual address + 4
                3. Restore the CPU state of a user program;
                4. increment the number of user stacks for currentThread
                   i.e.increment the process by 1
                5. Load the stack register with the stack address of new stack;
                6. Start the CPU so that it starts  running the user program thread;
        
        Exec(char *filename)
            This system call is used to create a new process. The new process
            which is created is like the one in fork but it has its own address
            space rather than sharing the address space with the spawning
            thread. The system call copies the code of the executable from the
            file specified by the argument and enters the entry into both the
            process table and the new address space's childThreads table. This
            system call then forks the proces  with exec_thread which then
            initializes the different registers and prepares the process to
            run.

        exec_thread()
            This is a helper function similar to kernel_thread(). This function
            takes the following steps: 
                1. Initialize the register by using currentThread->space.
                2. Call Restore State through currentThread->space.
                3. Call machine->Run() 

        Exit()
            This system call prepares the thread to exit properly. This funtion
            has the following steps
                if this is the last process in the system
                    Call Halt interrupt.
                if this is the last thread of the process but not the last
                process in the system
                    Clear the entry corresponding to this object from bitmap of
                    Process tables.  Remove entries form process table and
                    childThreads table.  Exit the current thread.
                if this is just another process neither the last nor the end of
                the system
                    Remove entry from the child process table and the theads
                    table.
                    Exit current Thread.

        Yield()
            Yield causes the current thread to give up the CPU.

    Part 2:
        
        AddrSpace class:

            The AddrSpace class has been redesigned to accomidate multiple
            processes and multiple threads within a process.  We allow for
            multiple processes by decoupling a page's virtual address from its
            physical address.  We maintain a global BitMap corresponding to all
            physical pages of memory and associate them with virtual pages as
            they are needed.  To create multiple threads the AddrSpace must
            allocate stack space for each thread.  We do this through the
            InitStack and ClearStack methods. AddrSpace doles out stack space
            starting at the largest address, so the virtual address space will
            look like this:

              Virtual Address Space
                      +-------------------+ 0
                      | code              |
                      +-------------------+
                      | init data         |
                      +-------------------+
                      | uninit data       |
                      +-------------------+
                      |                   |
                      | ... unused ...    |
                      |                   |
                      +-------------------+
                      | stack 2           |
                      +-------------------+
                      | stack 1           |
                      +-------------------+
                      | stack 0           |
                      +-------------------+ max Phys address

            Constructor

                This is where AddrSpace does most of the work, but the concept
                is pretty simple.  The constructor determines the number of
                pages necessary to hold the combined code and data sections of
                the program, as well as the number of pages necessary for the
                stack.  The pageTable is created at its maximum size to leave
                room for additional stacks.  Then we iterate over all pages in
                the table and allocate physical memory for those that need it,
                pages that are unused are marked as invalid.  Then we copy the
                code and data sections of the program into memory, making sure
                to put them in the proper position in physical memory.

            Destructor

                The destructor here performs the special tasks of deallocating
                any memory still associated with this process, and closing any
                open files.  It also performs the usual deletes on any
                variables created on the heap.

            InitRegisters

                InitRegisters has been modified to set StackReg to the bottom
                of the stack, as the position of the first stack relative to
                address 0 has changed from the provided code.

            int InitStack()

                Allocates memory for a new stack in this address space, sets
                the stack register to the bottom of the stack, and returns the
                id of the stack.  The id is necessary later to be able to clear
                the stack.

            void ClearStack(int id)

                Deallocates the memory associated with the passed stack id.
                The stack is marked as cleared so the virtual address can be
                reused for a new stack of a new thread.

            string readCString(char*);

                readCString is a convenience function for the benefit of system
                calls that allows a null-terminated character string to be
                passed without also specifying the length.  readCString takes
                the virtual addresss of the string and returns the string as a
                string object in kernel space.  This function takes care of the
                messiness of making sure a virtual address is valid and that it
                stays valid until the string terminates.

            void addChildThread(PID);           

                TODO

            void removeChildThread(PID);        

                TODO

            void killAllThreads();

                TODO

    Part 3:
        

IV. Implementation:

    + Files Modified
        userprog/addrspace.cc
        userprog/addrspace.h
        userprog/syscall.h
        userprog/exception.cc
        test/Makefile
        threads/thread.h
        threads/thread.cc
        threads/system.h
        threads/system.cc

    + Files added
        test/acquire.c
        test/createcv.c
        test/destroycv.c
        test/destroylock.c
        test/exec.c
        test/exectest.c
        test/fork.c
        test/halt.c
        test/itoa.c
        test/lockcreate.c
        test/print.c
        test/printtest.c

    + Data Structures added, and the file they were added to.
        userprog/addrspace.cc
            Lock* physMemMapLock
            BitMap physMemMap
            Lock* childLock
        userprog/system.h
            struct ProcessTable
        userprog/exception.cc
            struct LockWrapper
            struct ConditionWrapper
            
    + Data Structures modified, and the file they were added to.
        userprog/addrspace.cc/h: 
            class AddrSpace{
                Data Added:
                    Table locksTable;
                    Table CVTable;   
                    set<PID> childThreads;
                    Lock *childLock;
                    Lock* stackTableLock;
                    BitMap* stackTable;
                    unsigned int dataSize;
                    unsigned int dataPages;

                Methods Added:
                    int InitStack();
                    void ClearStack(int);
                    string readCString(char*);
                    void addChildThread(PID);           
                    void removeChildThread(PID);        
                    void killAllThreads();

                Methods modified:
                    constructor
                    destructor
                    InitRegisters
            }

        threads/thread.h
            class Thread{
                Data Added:
                    int PID;                           
                    int stackID;                     
            }

                
            
    + Functions added and in which file.
        

    + Functions modified and in which file.
        
V. Testing: (For each test case, you must show)
    + How to test

     -Test Case 1: Testing Creation of a Lock
      In this case a lock is created and assigned to a variable.
      The value of the variable is checked to be either valid
      or invalid.
    
      How to run in nachos:
      %userprog/nachos -x ../test/lockcreate
      
      
     -Test Case 2: Testing Destroy of a Lock
      In this case a lock is created and Destroyed If the lock
      is valid we again call a destroy.
    
      How to run in nachos:
      %userprog/nachos -d + -x ../test/destroylock | grep lock

      
     -Test Case 3: Testing Acquire of a Lock
      In this case a lock is created and Acquired.The debug
      version enables us to observe the System Call Acquire.
    
      How to run in nachos:
      %userprog/nachos -d + -x ../test/acquire | grep Acquire 
      
      
     -Test Case 4: Testing Create of a Condition Variable
      In this case a CV is created and assigned to a variable.
      The value of the variable is checked to be either valid
      or invalid.
    
      How to run in nachos:
      %userprog/nachos -x ../test/createcv  

  
     -Test Case 5: Testing Destroy of a CV
      In this case a CV is created and Destroyed If the CV
      is valid we again call a destroy.
    
      How to run in nachos:
      %userprog/nachos -d + -x ../test/destroycv | grep CV









    + Test Output
      
      -Test Case 1: Testing Creation of a Lock
       OUTPUT:
       Testing lock creation...Pass
       Testing lock creamain: Exit status: 0
       
       Here we see that lock created is valid.
       Thus the Lock Creation was Successful.
       
       
      -Test Case 2: Testing Destroy of a Lock
       OUTPUT:
       main: DestroyLock_Syscall: Successfully deleted lock 0 .
       main: DestroyLock_Syscall: Unable to find lock 0 for deletion.
       
       Here we observe that after the deletion of the Lock when
       another Destroy is called it states it is unable to
       find the lock.

       
      -Test Case 3: Testing Acquire of a Lock
       OUTPUT:
       main: Lock 0: AcquireLock_Syscall.

       The System Call Acquire is being Called.


      -Test Case 4: Testing Create of a Condition Variable
       OUTPUT:
       Testing CV creation...Pass
       Testing CV creatimain: Exit status: 0

       Here we see that CV created is valid.
       Thus the CV Creation was Successful.


      -Test Case 5: Testing Destroy of a Condition Variable
       OUTPUT:     
       main : DestroyCondition_Syscall: Successfully deleted CV 0 .
       main: DestroyCondition_Syscall: Unable to find CV 0 for deletion.
      
       Here we observe that after the deletion of the CV when
       another Destroy is called it states it is unable to
       find the CV.


VI. Discussion:
    + Experiment expectation.  
            
    + Experiment result.
        
    + Explanation

VII. Miscellaneous:
    It was not clear to us the options available for the architecture of the
    virtual address space (even after multiple questions and answers).  I have
    implemented it the way I think makes most sense, and the way most
    consistent with information I have seen about modern operating systems
    (code and data at low end, stacks at high end), even though this differs
    from a diagram I saw in class (stacks immediately follow code and data).  I
    think that this design is superior because under most conditions (< max
    stacks allocated) if a stack overflows, it overflows into unallocated area,
    which will cause a segfault, rather than overwriting the data area,
    followed by the code area, which could result in some very difficutl to
    explain bugs, if you were not looking for a stack overflow.


