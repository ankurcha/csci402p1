Title: Writeup for Project 4, Fall 2009

Date: 11/22/2009

Group Num 11: Name              Email               Student ID
              Ankur Chauhan     ankurcha@usc.edu    8478-1604-85
              Max Pflueger      pflueger@usc.edu    5888-2249-87
              Aneesha Mathew    aneesham@usc.edu    3976-3694-15

 vim:textwidth=75

I. Requirements:
    For this assignment we are required to port our multi-threaded hospital
    simulation into a networked hospital simulation.  Each hospital entity is
    required to exist at a unique position in the network, and will be composed
    of at least an entity thread and networking thread.  The entity thread
    should communicate exclusively with its networking thread, and the
    networking thread should take care of responding to external requests and
    sending packets for the entity thread.  The OS should not be modified in
    any way that is specific to the hospital simulation.  All synchronization
    must be done in a fully distributed manner.
        
II. Assumptions:
    - Reliable network: this simulation is not designed to handle lost packets
         or threads that die unexpectedly or lose connectivity.  
    - Packet ordering: we assume that all packets from a given sender will
         arrive in the order they were sent (NOT true between multiple senders)
    - Functions provided by NACHOS are generally bug free and perform as
         specified.
    - File system system calls are correct as provided.
    - Condition variable and Lock implementations will be identical to
         project 1.
    - Programs are provided with adequate stack space to avoid overflow.
    - Physical memory is sufficiently large to accomidate all processes.
         (i.e. simulated physical memory size can be increased until it is
         sufficient for all processes)
        
III. Design:

    Note: regarding the hosptial simulation we will only focus on design
          elements that have changed since project 2.

    + We chose to use the memory paradigm from project 2 for this project.

    + Configuration file design
            The configuration file is used to tell the number of entities of
            each type that we wish to create.
        The format of the configuration is fairly simple.
                Number of Patients, Number of Receptionists, Number of Door
                boys, Number of Doctors, Number of Cashiers, Number of Clerks,
                Number of Hospital Managers
        
        Example configuration file
          20,3,2,2,3,2,1

    + Hospital Layout
        Our hospital runs 7 instances of nachos, one for each type of hospital
        entity.  Each hospital entity is run as a process within nachos, and
        has two threads, an entity thread and a networking thread.  The
        hospital manager also has a third thread to ping the hospial on a
        regular basis and prevent a lockup due to old timestamps.  The total
        ordering algorithm always holds at least n-1 messages it cannot
        process, so it is essential to keep packets flowing.

    + Network Thread
        We designed our network thread to be the same for all hospital
        entities.  It is provided in the file netthread.c.  In that file is the
        main network thread function that will be forked by all hospital
        entities.  The job of the network thread is to do all communication
        between this hospital entity and all the other entities in the
        hospital.  It exchanges data with the entity thread by using a shared
        global data structure.  All of the global data structures are
        replicated across the all entities, and protected by distributed locks.
        When an entity wants to do something with the network, it sends a
        packet to its network thread specifying what to do.  If necessary the
        entity thread waits for the network thread to tell it to continue.

        The network thread processes message from its entity thread
        immediately, but it waits on total ordering for messages from external
        entities.  It does this by maintaining a priority queue of all the
        messages that have not yet been processed.  When a message is received
        it is inserted into the queue and the max timestamp for the sending
        entity is updated.  The min of max timestamp across all entities is
        updated, and then messages are popped off the top of the priority queue
        until the next one has a timestamp that is too large.  Then the thread
        waits on another receive.

    + Hospital Entity Threads

IV. Implementation:

    + Files Modified
        userprog/exception.cc
        userprog/addrspace.h|c
        userprog/syscall.h

    + Files added
        test/cash.c
        test/clerk.c
        test/disthosp.c
        test/doctor.c
        test/doorboy.c
        test/eventDispatcher.c
        test/eventDispatcher.h
        test/heap.c
        test/heap.h
        test/hospManager.c
        test/hospShared.c
        test/hospShared.h
        test/init.h
        test/itoa.c
        test/itoa.h
        test/netthread.c
        test/p2pnetwork.c
        test/p2pnetwork.h
        test/packet.c
        test/packet.h
        test/patient.c
        test/receptionist.c
        test/string.c
        test/string.h
    + Data Structures added, and the file they were added to.
        - test/packet.h
            Packet{
                int senderId;
                int timestamp;
                char data[MaxDataSize];
            };
         - test/eventDispatcher.h
            
    + Data Structures modified, and the file they were added to.

    + Functions added and in which file.
        - test/hospShared.h|c
            Packet* buildPacket_Receptionist(Packet *p, int id, int peopleInLine,
                    int currentToken);
            Packet *buildPacket_Doctor(Packet *p, int id, int peopleInLine,
                    int prescription, int patientToken);
            Packet *buildPacket_Cashier(Packet *p, int id, int lineLength, int patToken,
                    int fee, int payment, int sales);
            Packet *buildPacket_Clerk(Packet *p, int id, int patientsInLine, int payment,
                    int fee, int patPrescription, int sales);
            Packet *buildPacket_GlobalData(Packet *p, short variable, int val);
            Packet *buildPacket_GlobalListAppend(Packet *p, int key, int val);
            Packet *buildPacket_GlobalQueuePush(Packet *p, int val);
            Packet *buildPacket_GlobalQueuePop(Packet *p);
        
        - test/
    + Functions modified and in which file.

V. Testing: (For each test case, you must show)
    + How to test

    + Test Output

VI. Discussion:
    + Experiment expectation.
                            
    + Experiment result.

    + Explanation

VII. Miscellaneous:
    When compiling our user programs in the test directory, use make, not gmake
    (still use gmake everywhere else).

