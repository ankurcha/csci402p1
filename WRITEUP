Title: Writeup for Project 2, Fall 2009

Date: 09/23/2009

Group Num 11: Name              Email               Student ID
              Ankur Chauhan     ankurcha@usc.edu    8478-1604-85
              Max Pflueger      pflueger@usc.edu    5888-2249-87
              Aneesha Mathew    aneesham@usc.edu    3976-3694-15

 vim:textwidth=75

I. Requirements:
    Part 1:
        
        For part 1 of the project we are required to implement the suite of
        system calls and exception handling defined in the project handout.
        This includes the implementations of the system calls as well as test
        cases showing that the system calls are both correct and safe.  Exec
        and Fork in particular will require additional underlying mechanisms to
        produce the correct behavior.

    Part 2:
        
        For part 2 of the project we are required to modify the existing code
        to support multiple processes, and multiple threads within a process.
        In order to achieve this we have to allocate system memory in such a
        way that virtual addresses may not match physical addresses (to support
        multiple processes that want the same address space).  We also have to
        provide a mechanism for creating multiple stacks within a single
        process and address space for the threads of that process.  This
        section is closely tied to the part 1 system calls Exec and Fork which
        will use the code from part 2, as in part 1, tests must be provided to
        ensure that part 2 code is behaving properly and is safe from malicious
        user programs.

    Part 3:
        
        For part 3 of the project we are required to adapt our hospital
        simulation from project 1 to run as a user process with our project 2
        code.  Everything that was previously implemented as a thread of the
        kernel in project 1, will now be a thread of the user process.  It
        should be possible to run multiple Hospitals simultaneously as separate
        user threads.  We should provide tests to show that all of this
        behavior is correct.

II. Assumptions:

    We assume:
        -Functions provided by NACHOS are generally bug free and perform as
         specified.
        -File system system calls are correct as provided.
        -Condition variable and Lock implementations will be identical to
         project 1.
        -Programs are provided with adequate stack space to avoid overflow
        -Physical memory is sufficiently large to accomidate all processes.
         (i.e. simulated physical memory size can be increased until it is 
         sufficient for all processes)

III. Design:

    Part 1:
        
        The system calls have been implemented as they were described in the
        student documentation. Synchronization of the lockTable, Condition
        variables Table and the process table has been delt with by using the
        Locks internally and this aspect is made transparent to the user.

        LockId CreateLock(name)
            This system call is used to create a new Lock. Each lock, as it is
            created is entered into the LocksTable and then the lock is
            referenced using the lockId as returned by this function. In case
            of a failure in the creation of the lock or failure to import the
            lock into the lockTable the system call would return -1 as the
            lockId.

        Acquire(LockId)
            This system call is used to acquire a lock that had been created by
            the user. In case the lock does not exist, this system call would
            just ignore the error, print out a message, "unable to find
            lock...".  Release(LockId) This system call is used to release a
            lock that is currently acquired by the thread.  In case, the lock
            is not in the lockTable or if the lock is not currently acquired by
            the thread, the error is printed on the screen when in debug mode.

        Release(LockId)
            This used 

        DestroyLock(LockId)
            This system call is used to delete the lock which had been
            previously created. In case there are other threads in the waiting
            queue, the lock is simply marked for deletion, the actual deletion
            would then happen all the threads have left the queue and the last
            thread also performs the release.  At this point it will check if
            it is the only thread on the queue and the lock is marked for
            deleting, it will remove the lock from the lockTable and also
            delete the Lock from memory.

        CVId CreateCondition(name)
            This system call is used to create a new Condition Variable. Each
            condition variable, as it is created is entered into the condition
            variables table - CVTable and then the condition variable is
            referenced using the CVId as returned by this call. In case of
            failure in the creation of the condition variable or failure to
            import the CV to the CVTable the system call returns -1.
        
        Wait(CVId, LockId)
            This is used to call Wait on a condition variable using the lock
            that is given as the second argument to this call. In case of any
            errors, either the lock is non existant or CVId is invalid or the
            lock used with the CVId is not the one for which the CV is being
            used or the Lock is not currently held by the current Thread, the
            program/kernel doesn't halt, instead it just displays the error and
            simply returns.

        Signal(CVId, LockId)
            This signal is used to send a signal to a condition Variable
            referenced using CVId. All the error conditions are same as that
            for Wait system call. It causes a single thread waiting on the
            condition variable to wake up.

        Broadcast(CVId, LockId)
            This system call is same as signal but instead of waking up just
            one thread waiting on the condition variable, it wakes up all the
            threads that are waiting on the condition variable. The error
            conditions are same as that mentioned for Wait() system call and
            are ignored and execution continues.

        Fork(VoidFunctionPtr)
            This system call is used to fork a new thread. When we call this
            function we get the virtual address of the function to be forked
            from the machine register(2). Then we first make a new thread. And
            we make the address space pointer point to the same address space
            as that of the spawning process. We then fork the kernel_thread
            function with the virtual address of the function to initialize the
            registers and allocate a new stack. This call also creates the
            required entries to the process table and the childThreads table of
            the address space associated with this thread.

        kernel_thread()
            This is a helper function for the fork system call. It does the
            following steps:
                1. Load the Reg with virtual address.
                2. Load the Next Reg with virtual address + 4
                3. Restore the CPU state of a user program;
                4. increment the number of user stacks for currentThread
                   i.e.increment the process by 1
                5. Load the stack register with the stack address of new stack;
                6. Start the CPU so that it starts  running the user program thread;
        
        Exec(char *filename)
            This system call is used to create a new process. The new process
            which is created is like the one in fork but it has its own address
            space rather than sharing the address space with the spawning
            thread. The system call copies the code of the executable from the
            file specified by the argument and enters the entry into both the
            process table and the new address space's childThreads table. This
            system call then forks the proces  with exec_thread which then
            initializes the different registers and prepares the process to
            run.

        exec_thread()
            This is a helper function similar to kernel_thread(). This function
            takes the following steps: 
                1. Initialize the register by using currentThread->space.
                2. Call Restore State through currentThread->space.
                3. Call machine->Run() 

        Exit()
            This system call prepares the thread to exit properly. This funtion
            has the following steps
                if this is the last process in the system
                    Call Halt interrupt.
                if this is the last thread of the process but not the last
                process in the system
                    Clear the entry corresponding to this object from bitmap of
                    Process tables.  Remove entries form process table and
                    childThreads table.  Exit the current thread.
                if this is just another process neither the last nor the end of
                the system
                    Remove entry from the child process table and the theads
                    table.
                    Exit current Thread.

        Yield()
            Yield causes the current thread to give up the CPU.

    Part 2:
        
        AddrSpace class:

            The AddrSpace class has been redesigned to accomidate multiple
            processes and multiple threads within a process.  We allow for
            multiple processes by decoupling a page's virtual address from its
            physical address.  We maintain a global BitMap corresponding to all
            physical pages of memory and associate them with virtual pages as
            they are needed.  To create multiple threads the AddrSpace must
            allocate stack space for each thread.  We do this through the
            InitStack and ClearStack methods. AddrSpace doles out stack space
            starting at the largest address, so the virtual address space will
            look like this:

              Virtual Address Space
                      +-------------------+ 0
                      | code              |
                      +-------------------+
                      | init data         |
                      +-------------------+
                      | uninit data       |
                      +-------------------+
                      |                   |
                      | ... unused ...    |
                      |                   |
                      +-------------------+
                      | stack 2           |
                      +-------------------+
                      | stack 1           |
                      +-------------------+
                      | stack 0           |
                      +-------------------+ max Phys address

            Constructor

                This is where AddrSpace does most of the work, but the concept
                is pretty simple.  The constructor determines the number of
                pages necessary to hold the combined code and data sections of
                the program, as well as the number of pages necessary for the
                stack.  The pageTable is created at its maximum size to leave
                room for additional stacks.  Then we iterate over all pages in
                the table and allocate physical memory for those that need it,
                pages that are unused are marked as invalid.  Then we copy the
                code and data sections of the program into memory, making sure
                to put them in the proper position in physical memory.

            Destructor

                The destructor here performs the special tasks of deallocating
                any memory still associated with this process, and closing any
                open files.  It also performs the usual deletes on any
                variables created on the heap.

            InitRegisters

                InitRegisters has been modified to set StackReg to the bottom
                of the stack, as the position of the first stack relative to
                address 0 has changed from the provided code.

            int InitStack()

                Allocates memory for a new stack in this address space, sets
                the stack register to the bottom of the stack, and returns the
                id of the stack.  The id is necessary later to be able to clear
                the stack.

            void ClearStack(int id)

                Deallocates the memory associated with the passed stack id.
                The stack is marked as cleared so the virtual address can be
                reused for a new stack of a new thread.

            string readCString(char*);

                readCString is a convenience function for the benefit of system
                calls that allows a null-terminated character string to be
                passed without also specifying the length.  readCString takes
                the virtual addresss of the string and returns the string as a
                string object in kernel space.  This function takes care of the
                messiness of making sure a virtual address is valid and that it
                stays valid until the string terminates.

    Part 3:
        
                The hospital simulation of the project is composed of 3 main 
                files namely init.h, init.c and patient.c As this is a direct 
                port of the the project 1 part 3, It behaves in exactly the same 
                way.
                The init.h file contains the different header file declaration, 
                declaration of all the data structures and the variables that 
                would be used throughout the program.
                The important parts of the simulation consist of the 7 functions 
                that define the threads corresponding to the actors present in 
                the hospital, as well as the HospINIT function which brings all 
                the threads to life. These functions are stored in the init.c 
                file and provides the functionality to the different entities in 
                the simulation.
                To initialize all the variables in the simulation we use a set 
                of functions named: __Patients(), __Cashier(), __Receptionist and 
                so on. These have the same functionality as the constructors for 
                the corresponding Datastructures.

The functions which are forked as different threads are described below:
    
    patients(int ID)
            The patient threads behave in the following way:
            1. Come to the Hospital
                When the patient comes into being, it acquires a lock over
                all the lines of the receptionist so that it can take the
                decision of which line is the shortest.
            2. Meets the receptionist to get a unique token number
                At this point the patient is waiting on the Condition Variable
                for the receptionist that it selected in the previous step, 
                till the point the receptionist signals the patient to come 
                forward and take the token generated by it. This is done in
                a two step handshake. After getting the token, the patient 
                randomly assigns to itself a doctor.
            3. Stands in line to get a chance to meet the doctor.
                After selecting the doctor, the patient goes and waits on
                that doctors waiting queue till it gets a signal to proceed
                form the doorboy that is helping that doctor.
            4 Waits for the door boy to call them when their turn comes.
                During this time, the doctor may go on break and only when the
                doctor returns he can start consulting the patient therefore
                the patient must wait for the doctor to call him.
            5. Consults the doctor.
                During this time the patient and doctore interact, the
                consultation involves the doctor to yield for a random number
                of cycles.  During this, the patient passes its token number to
                the doctor.
            6. Gets the prescription
                The patient is assigned a number(randomly generated) which is 
                taken as the prescription and would be later used to obtain 
                medicines from the pharmacy clerk.
            7. Comes out to get in the shortest line of a cashier
                When the doctor signals the patient that he is done consulting,
                the patient leaves and searches for the shortest line among
                all the cashiers. This is done in the exact same manner as 
                we did for selecting the receptionist in the step 2.
            8. Ask the cashier about the consultancy fees
                When the cashier signals the patient, the patient provides
                its token number and the cashier looks up the fees to be taken
                from this patient as directed by the doctor. This is stored
                in a linked list which has the key value pairings of the token
                to the fee to be collected.
            10. Pays the consultancy fees
                Once the cashier signals the patient to pay the fees, a
                handshake of wait and signal calls takes place between them
                which denotes the payment of the fees by the patient to the
                cashier.  Once this is done, the patient thread continues.
            11. Meets the pharmacy clerk to buy medicines.
                The patient thread, again uses the process as desctibes in 
                step 2 to calculate which clerk line it should get in to.
                Then it waits in the queue to be signalled by the corresponding
                clerk.
            12. Gives the prescription
                When the pharmacy clerk signals the patient, the patient
                thread replies by setting the prescription number given by
                the doctor. This is then used to get the medicines.
            13. Gets the medicine
                The pharmacy clerk will reply with a number denoting the
                medicines that the patient is supposed to get. This whole
                process is done in a similar handshake manner involving signals
                from the clerk thread to the waiting patient thread.
            14. Pays the bill amount
                As a final step, the patient does another signal on the waiting
                clerk thread to denote the payment for he medicines that it
                received in the previous step. After this the work of the
                patient thread is over and it continues to terminate.
            15. Leaves the hospital
                The patient thread terminates and ceases to exit.

        doctor(int ID)
            The doctor function represents a given doctor in our hospital,
            identified by the ID value.  The doctor runs in a loop, conducting
            the following tasks (in order): pull a doorboy off the doorboy
            queue, optionally take a break, tell the doorboy to send in a
            patient, consult with the patient, give the patient a prescription,
            and wait for the patient to leave.  Along the way the doctor also
            has to save his consulting fees where the cashier can find them, we
            use a list that links patient tokens to fees.  

            Our doorboys wait in line for a doctor to ask for their assistance.
            When a doctor starts he pulls a doorboy off that queue and waits
            for the doorboy to signal that they have arrived.  Once the doorboy
            arrives the doctor decides whether or not to take a break, and
            takes his break while the doorboy waits.  When he comes back he
            signals the doorboy that he is ready for a patient and waits for
            the patient to arrive.  The patient arrives on the same lock and CV
            that the doorboy was using.  After a consulting delay the doctor
            sets a prescription value for the patient to pick up and records a
            fee for the patient associated with the patient's token.  Then the
            doctor signals the patient indicating the values are prepared and
            waits for the patient to leave.  Once the patient has left the
            doctor repeats his loop.

        receptionist(int ID)
            The receptionist first acquires a lock to check all its lines
            called recpLineLock.The receptionist wakes a patient up by using
            his condition variable(receptionCV)to signal the patient.It checks
            the people in line and now uses a lock with the first patient in
            line to acquire mutual exclusion for further transactions. It first
            gives the patient a token and this transaction is carried on using
            the token Lock.  After all transactions are over, it releases the
            transaction Lock.  It checks for more patients if there are none it
            goes to sleep.It waits gor the hopsital Manager to signal it on its
            Break condition Variable(ReceptionistBreakCV).
        
        cashier(int ID)
            The cashier first acquires a lock on all the cashier queues and
            signals the patient on the top of his queue using his condition
            Variable(lineCV).For other transaction it uses its Transaction
            Lock(transLock).It looks up a linkedlist structure, uses the
            patient token number and gets the cost using the getValue()
            function.This has its own feeListLock. It waits for payment on its
            trasaction Condition Variable(TransCV).It calculates the total
            sales and after all these transactions releases the Transaction
            Lock(transLock). It goes to sleep if there are no patients in the
            Line and is woken up by a signal by the Hospital manager on its
            Line Condition Variable(LineCV).

        doorboy(int ID)
            To organize the doorboy threads such that all of the doorboys are
            available to which ever doctor wants them and that there is no
            binding of a doorboy to a particular doctor, they are put in a
            queue, made using a condition variable called doorboyLineCV.  The
            doctors signal for a doorboy whenever they are ready to accept more
            patients. The requests for doorboys are also queued onto a list
            wakingDoctorList and as each of the doorboys come alive they pick
            up each of these requests and service the corresponding doctor.  At
            this time, the doorboys check the queue of patients of that doctor
            and and tells the signals the patients, if any, to continue to meet
            the doctor.  In case there are no patients that are waiting for the
            doctor, the doorboy goes to sleep and would only wake up by getting
            signalled by the Hospital Manager.  This process keeps repeating
            till all the patients are done.
            

        clerk(int ID)
            The Pharmacy clerk first tries to acquire the lock to all the Clerk
            lines called ClerkLinesLock to find out how many patients are in
            his line.  Once there is a patient in his queue, the patient is
            serviced using a lock called a transaction lock(ClerkTransLock), to
            achieve mutual exclusion.  During the trasaction, The patient gives
            the clerk his prescription and waits for the cost of his
            medication. The clerk then signals with the amount, after which the
            patient pays the clerk and signals him once he finished. When all
            the transactions have finished the lock is released.  It calculates
            the Totalsales using a lock to protect its data called the
            PaymentLock. when there are no patients in line, it ges to sleep
            and waits for the Hospital Manager to wake him up by signaling him.
            

        hospitalManager(int ID)
            The hospital manager is a thread which has only one instance per
            simulation. Its job is to go on rounds at random intervals (done
            by yielding to other threads for some randomly selected times).
            The hospital manager keeps a track of the patients that are waiting
            in the simulation and exits only when this number reaches zero.
            The hospital manager thread keeps checking the receptionists',
            cashier, doorboy and pharmacy clerks' line of patients and signals
            them to wake up in case there are any.
            Also, in case of Cashier and Pharmacy clerk, the hospital manager
            also queries them for the total sales that for the simulation.
            We can see this number grow from 0 as the simulation progresses.
            Once the all the patients have been terminated, the hospital manager
            also kills itself and other threads will all go to sleep and thereby
            ending the simulation.

        HospINIT(int testmode = 0)
            HospINIT is a relatively simple function that starts up threads for
            the requisite number of each hosptial actor.  It has additional
            code that starts up special numbers of threads in test cases.  For
            each thread type, HospINIT randomly generates the number of that
            type of thread to start based on the max and min for that thread
            type, and starts that many threads.

IV. Implementation:

    + Files Modified
        userprog/addrspace.cc
        userprog/addrspace.h
        userprog/syscall.h
        userprog/exception.cc
        test/Makefile
        threads/thread.h
        threads/thread.cc
        threads/system.h
        threads/system.cc

    + Files added
        test/acquire.c
        test/createcv.c
        test/destroycv.c
        test/destroylock.c
        test/exec.c
        test/exectest.c
        test/fork.c
        test/halt.c
        test/itoa.c
        test/init.c
        test/init.h
        test/lockcreate.c
        test/print.c
        test/printtest.c
        test/queue.c
        test/queue.h

    + Data Structures added, and the file they were added to.
        userprog/addrspace.cc
            Lock* physMemMapLock
            BitMap physMemMap
            Lock* childLock
        userprog/system.h
            struct ProcessTable
        userprog/exception.cc
            struct LockWrapper
            struct ConditionWrapper
        test/queue.h
            struct queue_element
            struct Queue
        init.h:
            struct list_element
            struct list
            struct Receptionists
            struct Cashier
            struct PharmacyClerks
            struct Doctor
            struct DoorBoy
            
    + Data Structures modified, and the file they were added to.
        userprog/addrspace.cc/h: 
            class AddrSpace{
                Data Added:
                    Table locksTable;
                    Table CVTable;   
                    set<PID> childThreads;
                    Lock *childLock;
                    Lock* stackTableLock;
                    BitMap* stackTable;
                    unsigned int dataSize;
                    unsigned int dataPages;

                Methods Added:
                    int InitStack();
                    void ClearStack(int);
                    string readCString(char*);

                Methods modified:
                    constructor
                    destructor
                    InitRegisters
            }

        threads/thread.h
            class Thread{
                Data Added:
                    int PID;                           
                    int stackID;                     
            }

                
            
    + Functions added and in which file.
        test/print.c
            print
        test/queue.h/c
            Queue_Push
            Queue_Pop
            Queue_IsEmpty
         test/init.c
            void doorboy(int)
            void doctor(int)
            void receptionist(int)
            void cashier(int)
            void clerk(int)
            void hospitalManager(int)
            void createDoorboy()
            void createdoctor()
            void createreceptionist()
            void createcashier()
            void createclerk()
            void createhospitalManager()
            void HospINIT()
            int test1()
            int test2()
            int test4()
            int test7()
         test/acquire.c
         test/createcv.c
         test/destroycv.c
         test/destroylock.c
         test/exec.c
         test/exectest.c
         test/fork.c
         test/itoa.c
            itoa()
         test/lockcreate.c
         test/print.c
            print()
         test/printtest.c

    + Functions modified and in which file.
        
V. Testing: (For each test case, you must show)
    + How to test

     -Test Case 1: Testing Creation of a Lock
      In this case a lock is created and assigned to a variable.
      The value of the variable is checked to be either valid
      or invalid.
    
      How to run in nachos:
      %userprog/nachos -x ../test/lockcreate
      
      
     -Test Case 2: Testing Destroy of a Lock
      In this case a lock is created and Destroyed If the lock
      is valid we again call a destroy.
    
      How to run in nachos:
      %userprog/nachos -d + -x ../test/destroylock | grep lock

      
     -Test Case 3: Testing Acquire of a Lock
      In this case a lock is created and Acquired.The debug
      version enables us to observe the System Call Acquire.
    
      How to run in nachos:
      %userprog/nachos -d + -x ../test/acquire | grep Acquire 
      
      
     -Test Case 4: Testing Create of a Condition Variable
      In this case a CV is created and assigned to a variable.
      The value of the variable is checked to be either valid
      or invalid.
    
      How to run in nachos:
      %userprog/nachos -x ../test/createcv  

  
     -Test Case 5: Testing Destroy of a CV
      In this case a CV is created and Destroyed If the CV
      is valid we again call a destroy.
    
      How to run in nachos:
      %userprog/nachos -d + -x ../test/destroycv | grep CV

    -Test Case 6:Testing Exec
      We test the exec Syscall by write a test file called
      exec.c which uses the System Call Exec to execute a file
      called exectest. Exectest is a simple Hello World Program.
      
      How to run in nachos:
      %userprog/nachos -x ../test/exec

    -Test Case 7:Testing Fork
     We test the Fork System Call by writing a test file called fork.c
     fork.c Forks a function in the same address space as the current thread.

     How to run in nachos:
     %userprog/nachos -x ../test/fork

    -Test Case 8: Multiple concurrent hospital simulations and exec
        We test that the Exec system call and also test that concurrent instances
        of the hospital simulation can be started using exec() and will continue
        to work without any problems
                %userprog/nachos -x ../test/multih

        *Test cases form Project 1 are also carried to this Project and are invoked
        via a command line argument to nachos
                ./nachos -rs <seed> -x ../test/init <test case number>
        valid test case number values:
                    1, 2, 3, 4, 51, 52, 53, 6, 7, 8, 9, 10, 11

    + Test Output
      
      -Test Case 1: Testing Creation of a Lock
       OUTPUT:
       Testing lock creation...Pass
       Testing lock creamain: Exit status: 0
       
       Here we see that lock created is valid.
       Thus the Lock Creation was Successful.
       
       
      -Test Case 2: Testing Destroy of a Lock
       OUTPUT:
       main: DestroyLock_Syscall: Successfully deleted lock 0 .
       main: DestroyLock_Syscall: Unable to find lock 0 for deletion.
       
       Here we observe that after the deletion of the Lock when
       another Destroy is called it states it is unable to
       find the lock.

       
      -Test Case 3: Testing Acquire of a Lock
       OUTPUT:
       main: Lock 0: AcquireLock_Syscall.

       The System Call Acquire is being Called.


      -Test Case 4: Testing Create of a Condition Variable
       OUTPUT:
       Testing CV creation...Pass
       Testing CV creatimain: Exit status: 0

       Here we see that CV created is valid.
       Thus the CV Creation was Successful.


      -Test Case 5: Testing Destroy of a Condition Variable
       OUTPUT:     
       main : DestroyCondition_Syscall: Successfully deleted CV 0 .
       main: DestroyCondition_Syscall: Unable to find CV 0 for deletion.
      
       Here we observe that after the deletion of the CV when
       another Destroy is called it states it is unable to
       find the CV.
       
    -Test Case 6:Testing Exec
      OUTPUT:
       Exec_Syscall: Arg: ../test/exectest
       EXECED
       main: Exit status: 0
       processTable->processCounter1
       currentThread->space->childThreads: 0
       Hello World../test/exectest: Exit status: -1
       processTable->processCounter1
       currentThread->space->childThreads: 0
       No threads ready or runnable, and no pending interrupts.
       Assuming the program completed.
       Machine halting!
      
      Thus Hello World is printed and the program is exited.
      
     -Test Case 7:Testing Fork
      OUTPUT:
       Create Lock
       Forking thread
       main forked func1
       main: WaitCV_Syscall: Called for CVId: 0 lockId 0 .
       func1 forked and running
       func1 acquired lock
       func1 Exiting with exit status 0
       main: Exit status: 0
       Machine halting!
       Ticks: total 2474, idle 0, system 900, user 1574
       Disk I/O: reads 0, writes 0
       Console I/O: reads 0, writes 0
       Paging: faults 0
       Network I/O: packets received 0, sent 0
       Cleaning up...

     -Test Case 8: Multiple Hospital Instances
        We get the entry points for the 3 hospitals one by one ( as we exec the processes)
        When we are done selecting the simultion test option each of the processes give
        output concurrently as they are running concurrently in NACHOS.

        *Output for the other 11 test cases from project 1. Please refer Writeup
        of the project 1 for output details. 
      
VI. Discussion:
    + Experiment expectation. 
        The hospital simulation should behave exactly as it it did as in Project
        Also, As we have completly ported the existing project 1, and as all the
        test cases that we had made for the previous project have successfulluy
            
    + Experiment result.
        All the test cases were appropriately implemented and the
        simulation performed as expected for any given value of -rs. In
        addition, in order to enable easy tracability of the interactions
        the verbosity of the threads has been kept high, with almost all
        interactions being logged to standard output.
    
    + Explanation
        As the the expectation and the results match, we conclude that both 
        the parts have been properly implemented.

VII. Miscellaneous:
    It was not clear to us the options available for the architecture of the
    virtual address space (even after multiple questions and answers).  I have
    implemented it the way I think makes most sense, and the way most
    consistent with information I have seen about modern operating systems
    (code and data at low end, stacks at high end), even though this differs
    from a diagram I saw in class (stacks immediately follow code and data).  I
    think that this design is superior because under most conditions (< max
    stacks allocated) if a stack overflows, it overflows into unallocated area,
    which will cause a segfault, rather than overwriting the data area,
    followed by the code area, which could result in some very difficult to
    explain bugs, if you were not looking for a stack overflow.


