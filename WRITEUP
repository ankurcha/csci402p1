Title: Writeup for Project 2, Fall 2009

Date: 09/23/2009

Group Num 11: Name              Email               Student ID
              Ankur Chauhan     ankurcha@usc.edu    8478-1604-85
              Max Pflueger      pflueger@usc.edu    5888-2249-87
              Aneesha Mathew    aneesham@usc.edu    3976-3694-15

 vim:textwidth=75

I. Requirements:
    + Part 1:

    + Part 2:

II. Assumptions:

    We assume:

III. Design:

    Part 1:

    Part 2:
        
        The AddrSpace class has been redesigned to accomidate multiple
        processes and multiple threads within a process.  We allow for multiple
        processes by decoupling a page's virtual address from its physical
        address.  We maintain a global BitMap corresponding to all physical
        pages of memory and associate them with virtual pages as they are
        needed.  To create multiple threads the AddrSpace must allocate stack
        space for each thread.  We do this through the InitStack and ClearStack
        methods. AddrSpace doles out stack space starting at the largest
        address, so the virtual address space will look like this:

          Virtual Address Space
                  +-------------------+ 0
                  | code              |
                  +-------------------+
                  | init data         |
                  +-------------------+
                  | uninit data       |
                  +-------------------+
                  |                   |
                  | ... unused ...    |
                  |                   |
                  +-------------------+
                  | stack 2           |
                  +-------------------+
                  | stack 1           |
                  +-------------------+
                  | stack 0           |
                  +-------------------+ 0xffff...

        AddrSpace {
            int InitStack()

                Allocates memory for a new stack in this address space, sets
                the stack register to the bottom of the stack, and returns the
                id of the stack.  The id is necessary later to be able to clear
                the stack.

            void ClearStack(int id)

                Deallocates the memory associated with the passed stack id.
                The stack is marked as cleared so the virtual address can be
                reused for a new stack of a new thread.

        }

    Part 3:
        

IV. Implementation:

    + Files Modified
        addrspace.cc
        addrspace.h

    + Files added

    + Data Structures added, and the file they were added to.


    + Data Structures modified, and the file they were added to.


    + Functions added and in which file.

    + Functions modified and in which file.
        
V. Testing: (For each test case, you must show)
    + How to test

     -Test Case 1: Testing Creation of a Lock
      In this case a lock is created and assigned to a variable.
      The value of the variable is checked to be either valid
      or invalid.
    
      How to run in nachos:
      %userprog/nachos -x ../test/lockcreate
      
      
     -Test Case 2: Testing Destroy of a Lock
      In this case a lock is created and Destroyed If the lock
      is valid we again call a destroy.
    
      How to run in nachos:
      %userprog/nachos -d + -x ../test/destroylock | grep lock

      
     -Test Case 3: Testing Acquire of a Lock
      In this case a lock is created and Acquired.The debug
      version enables us to observe the System Call Acquire.
    
      How to run in nachos:
      %userprog/nachos -d + -x ../test/acquire | grep Acquire 
      
      
     -Test Case 4: Testing Create of a Condition Variable
      In this case a CV is created and assigned to a variable.
      The value of the variable is checked to be either valid
      or invalid.
    
      How to run in nachos:
      %userprog/nachos -x ../test/createcv  

  
     -Test Case 5: Testing Destroy of a CV
      In this case a CV is created and Destroyed If the CV
      is valid we again call a destroy.
    
      How to run in nachos:
      %userprog/nachos -d + -x ../test/destroycv | grep CV









    + Test Output
      
      -Test Case 1: Testing Creation of a Lock
       OUTPUT:
       Testing lock creation...Pass
       Testing lock creamain: Exit status: 0
       
       Here we see that lock created is valid.
       Thus the Lock Creation was Successful.
       
       
      -Test Case 2: Testing Destroy of a Lock
       OUTPUT:
       main: DestroyLock_Syscall: Successfully deleted lock 0 .
       main: DestroyLock_Syscall: Unable to find lock 0 for deletion.
       
       Here we observe that after the deletion of the Lock when
       another Destroy is called it states it is unable to
       find the lock.

       
      -Test Case 3: Testing Acquire of a Lock
       OUTPUT:
       main: Lock 0: AcquireLock_Syscall.

       The System Call Acquire is being Called.


      -Test Case 4: Testing Create of a Condition Variable
       OUTPUT:
       Testing CV creation...Pass
       Testing CV creatimain: Exit status: 0

       Here we see that CV created is valid.
       Thus the CV Creation was Successful.


      -Test Case 5: Testing Destroy of a Condition Variable
       OUTPUT:     
       main : DestroyCondition_Syscall: Successfully deleted CV 0 .
       main: DestroyCondition_Syscall: Unable to find CV 0 for deletion.
      
       Here we observe that after the deletion of the CV when
       another Destroy is called it states it is unable to
       find the CV.


VI. Discussion:
    + Experiment expectation.  
            
    + Experiment result.
        
    + Explanation

VII. Miscellaneous:
