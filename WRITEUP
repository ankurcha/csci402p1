Title: Writeup for Project 4, Fall 2009

Date: 11/22/2009

Group Num 11: Name              Email               Student ID
              Ankur Chauhan     ankurcha@usc.edu    8478-1604-85
              Max Pflueger      pflueger@usc.edu    5888-2249-87
              Aneesha Mathew    aneesham@usc.edu    3976-3694-15

 vim:textwidth=75

I. Requirements:
    For this assignment we are required to port our multi-threaded hospital
    simulation into a networked hospital simulation.  Each hospital entity is
    required to exist at a unique position in the network, and will be composed
    of at least an entity thread and networking thread.  The entity thread
    should communicate exclusively with its networking thread, and the
    networking thread should take care of responding to external requests and
    sending packets for the entity thread.  The OS should not be modified in
    any way that is specific to the hospital simulation.  All synchronization
    must be done in a fully distributed manner.
        
II. Assumptions:
    - Reliable network: this simulation is not designed to handle lost packets
         or threads that die unexpectedly or lose connectivity.  
    - Packet ordering: we assume that all packets from a given sender will
         arrive in the order they were sent (NOT true between multiple senders)
    - Functions provided by NACHOS are generally bug free and perform as
         specified.
    - File system system calls are correct as provided.
    - Condition variable and Lock implementations will be identical to
         project 1.
    - Programs are provided with adequate stack space to avoid overflow.
    - Physical memory is sufficiently large to accomidate all processes.
         (i.e. simulated physical memory size can be increased until it is
         sufficient for all processes)
        
III. Design:

    Note: regarding the hosptial simulation we will only focus on design
          elements that have changed since project 2.

    + We chose to use the memory paradigm from project 2 for this project.

    + Configuration file design
            The configuration file is used to tell the number of entities of
            each type that we wish to create.
        The format of the configuration is fairly simple.
                Number of Patients, Number of Receptionists, Number of Door
                boys, Number of Doctors, Number of Cashiers, Number of Clerks,
                Number of Hospital Managers
        
        Example configuration file
          20
          3
          2
          2
          3
          2
          1
        
        This configuration file MUST be named 'configfile' and must be placed
        in the same folder as the one where we are running nachos.

    + Hospital Layout
        Our hospital runs 7 instances of nachos, one for each type of hospital
        entity.  Each hospital entity is run as a process within nachos, and
        has two threads, an entity thread and a networking thread.  The
        hospital manager also has a third thread to ping the hospial on a
        regular basis and prevent a lockup due to old timestamps.  The total
        ordering algorithm always holds at least n-1 messages it cannot
        process, so it is essential to keep packets flowing.

    + Network Thread
        We designed our network thread to be the same for all hospital
        entities.  It is provided in the file netthread.c.  In that file is the
        main network thread function that will be forked by all hospital
        entities.  The job of the network thread is to do all communication
        between this hospital entity and all the other entities in the
        hospital.  It exchanges data with the entity thread by using a shared
        global data structure.  All of the global data structures are
        replicated across the all entities, and protected by distributed locks.
        When an entity wants to do something with the network, it sends a
        packet to its network thread specifying what to do.  If necessary the
        entity thread waits for the network thread to tell it to continue.

        The network thread processes message from its entity thread
        immediately, but it waits on total ordering for messages from external
        entities.  It does this by maintaining a priority queue of all the
        messages that have not yet been processed.  When a message is received
        it is inserted into the queue and the max timestamp for the sending
        entity is updated.  The min of max timestamp across all entities is
        updated, and then messages are popped off the top of the priority queue
        until the next one has a timestamp that is too large.  Then the thread
        waits on another receive.

    + Hospital Entity Threads
        The hospital entity threads have been more or less unaltered from that
        of project 1 and hence should be expected to behave in the same manner. The
        changes which were made to the system in order for it to become a completely
        distributed network application is that it first of all sends out a NODE_READY
        packet at the start of the thread and waits for a GO reply from the other
        packets. This assures us that once the node starts to execute all the other
        nodes (as per the config file) have been spawned and are running as expected.
    
        Each of the hospital entities are divided into separate user programs and are
        all spawned using the distHosp user program which reads the config file and
        spawns the required number of user programs of the required type. The entity
        that is spawned is determined by the machine id passed (-m) parameter to
        nachos. Hence, for 0 we get patients, 1 - receptionists, 2 - doorboys, 3 -
        doctors, 4 - cashiers, 5 - clerks, 6 - hospital manager.
        
        To enable network based functionality for Locks and the CVs are acquired /
        released / Wait / Signal / Broadcast using the HLock_Acquire / HLock_Release /
        HCV_Wait / HCV_Signal / HCV_Broadcast. As the data changes in any one of the
        network it has to be propogated thoughout the network and updated everywhere
        else, to support this we have many HUpdate_ prefixed functions which take care
        of any such updation. These fuctions either work on specific data structures eg
        the fee list or the walkingDoctorID queue or they are generic for the other
        globally defined data. For the globally defined data we have enumerated an
        identifier for each one of them so that we can easily identify which one has to
        be updated when we get a DATA_UPDATE request.

IV. Implementation:

    + Files Modified
        userprog/exception.cc
        userprog/addrspace.h|c
        userprog/syscall.h

    + Files added
        test/cash.c
        test/clerk.c
        test/disthosp.c
        test/doctor.c
        test/doorboy.c
        test/eventDispatcher.c
        test/eventDispatcher.h
        test/heap.c
        test/heap.h
        test/hospManager.c
        test/hospShared.c
        test/hospShared.h
        test/init.h
        test/itoa.c
        test/itoa.h
        test/netthread.c
        test/p2pnetwork.c
        test/p2pnetwork.h
        test/packet.c
        test/packet.h
        test/patient.c
        test/receptionist.c
        test/string.c
        test/string.h
    + Data Structures added, and the file they were added to.
        - test/packet.h
            Packet{
                int senderId;
                int timestamp;
                char data[MaxDataSize];
            };
         - test/eventDispatcher.h
         - test/p2pnetwork.h
            int myNetThreadMbox;
            int readyCount;
            int numberOfEntities[7];   
            
            LockId netthread_Lock;
            CVId netthread_CV;
            LockId ping_Lock;
            CVId ping_CV;
            
            struct Resource {
                int name;
                int timestamp; /* record when the request was made */
                char valid; /* 0 init */
                int replies; /* Number of replies that are received */
                int state; /* can be RES_HELD or RES_REQ or RES_NONE */
            };
            
            Resource resources[MAX_RESOURCES];
            enum {
                  RES_HELD, RES_REQ, RES_NONE
            };
            QueueElement queue[MAX_CV][MAX_CV_QUEUE_LEN];
            MessageQueue pendingCVQueue[MAX_CV];
            
            enum {
                EMPTY = 0x00,
                LOCK_ACQUIRE = 0x01,
                LOCK_RELEASE = 0x02,
                LOCK_OK = 0x04,
                CV_WAIT = 0x07,
                CV_SIGNAL = 0x08,
                CV_BROADCAST = 0x09,
                NODE_READY = 0x0C,
                RECP_DATA_UPDATE = 0x0D,
                PAT_DATA_UPDATE = 0x0E,
                DOORB_DATA_UPDATE = 0x0F,
                DOC_DATA_UPDATE = 0x10,
                CASH_DATA_UPDATE = 0x11,
                CLERK_DATA_UPDATE = 0x12,
                MAN_DATA_UPDATE = 0x13,
                GLOBAL_DATA_UPDATE = 0x14,
                DO_PING = 0x15,
                PING = 0x16,
                PONG = 0x17,
                KILL = 0x18,
                GO = 0x19
            };
    
            /* Entity Identification */
            enum {
                RECEPTIONIST_NODE = 0x0D,
                PATIENT_NODE = 0x0E,
                DOCTOR_NODE = 0x0F,
                DOORBOY_NODE = 0x10,
                CASHIER_NODE = 0x11,
                CLERK_NODE = 0x12,
                MANAGER_NODE = 0x13
            };

            int myMbox;

    + Data Structures modified, and the file they were added to.
            All the project 3 specific datastructures have been either removed
            or surrounded using macro gaurd. This enabled us to go forward using the the
            project with all the system calls developed as a part of the project 3. Only
            the memory management (TLB) based things have been thrown out.        +
    
    Functions added and in which file.
        - test/hospShared.h|c
            Packet* buildPacket_Receptionist(Packet *p, int id, int peopleInLine,
                    int currentToken);
            Packet *buildPacket_Doctor(Packet *p, int id, int peopleInLine,
                    int prescription, int patientToken);
            Packet *buildPacket_Cashier(Packet *p, int id, int lineLength, int patToken,
                    int fee, int payment, int sales);
            Packet *buildPacket_Clerk(Packet *p, int id, int patientsInLine, int payment,
                    int fee, int patPrescription, int sales);
            Packet *buildPacket_GlobalData(Packet *p, short variable, int val);
            Packet *buildPacket_GlobalListAppend(Packet *p, int key, int val);
            Packet *buildPacket_GlobalQueuePush(Packet *p, int val);
            Packet *buildPacket_GlobalQueuePop(Packet *p);
        
        - test/p2pnetwork.h|c
            int getMboxNum();
            void initializeSystem();
            void initResources();
            int addResource(int id, int state);
            int deleteResource(int id);
            int getResourceStatus(int resourceID);
            int updateResourceStatus(int resourceID, int newStatus);
            int getResourceReplies(int resourceID);
            int updateResourceReplies(int resourceID, int replies);
            void SendAll(int packetType);
            void HMultiPing();
            void HKill();
            void Kill();
            int HLock_Acquire(int HlockId);
            int HLock_Release(int HlockId);
            int DistLock_Acquire(int name);
            int DistLock_Release(int name);
            int HCV_Signal(int HCVId, int HLockId);
            int HCV_Wait(int HCVId, int HLockId);
            int HCV_Broadcast(int HCVId, int HLockId);
            int DistCV_Wait(int CVID, int LockID);
            int DistCV_Signal(int CVID);
            void Process_CV_Signal(Packet pkt);
            int SyncPrint(char *, int EntityID);
            int HTable_Update(int tableId, int key, int value);
            int SendToNetwork();
            void readConfig();
            int getCV_Lock_Mapping(int CVID);
            void HNodeReady();
            int HDataUpdate_Recp(int id, int peopleInLine, int currentToken);
            int HDataUpdate_Pat(int id);
            int HDataUpdate_Doorb(int id);
            int HDataUpdate_Doc(int id, int peopleInLine, int prescription,
                                int patientToken);
            int HDataUpdate_Cash(int id, int lineLength, int patToken, int fee,
                                int payment, int sales);
            int HDataUpdate_Clerk(int id, int patientsInLine, int payment, int fee,
                                int patPrescription, int sales);
            int HDataUpdate_HospMan(int id);
            void HPing_NetThread();
            int HGlobalDataUpdate(short Variable, int val);
            int HGlobalListAppendUpdate(int key, int value);
            int HGlobalQueuePopUpdate();
            int HGlobalQueuePushUpdate(int value);
            int DistUpdate_Send(Packet p);
            int DistGlobalData_Send(Packet p);
        - test/packet.h|c
            int Packet_Receive(int mbox, int *senderId, int *senderMBox,
                    Packet *receivedPacket);

            int Packet_Send(int receiverId, int recMBox, int senderMBox, Packet*);

            void SerializePacket(Packet *p, char* message);
            void DeserializePacket(Packet *p, char* message);
            int copyOutInt(char* message, int index);
            void copyInInt(char* message, int index, int val);
            int copyOutShort(char* message, int index);
            void copyInShort(char* message, int index, int val);
            void copyOutData(char* message, int index, char* data, int length);
            void copyInData(char* message, int index, char* data, int length);
            void memcopy(char* left, char* right, int length);
        - test/netthread.c
            void processExternalPacket(Packet pkt, int senderId, int senderMbox);
            void processLocalPacket(Packet pkt);
            void network_thread();
        - test/heap.h|c
            void Heap_Push(Message* start, int* length);
            Message* Heap_ExtractMin(Message* start, int* length);
        - test/string.h|c
            int strlen(const char *str);
            char* strcat(char *dst, const char *src);
            int strcmp(const char *dst, const char *src);
            char* strcpy(char *s1, const char *s2);
        - test/patient.c
            void createpatient();
            void patient();
            void main();
        - test/receptionist.c
            void createreceptionist();
            void receptionist();
            void main();
        - test/doorboy.c
            void createdoorboy();
            void doorboy();
            void main();
        - test/doctor.c
            void createdoctor();
            void doctor();
            void main();
        - test/cash.c
            void createcashier();
            void cash();
            void main();
        - test/clerk.c
            void createclerk();
            void clerk();
            void main();
        - test/hospManager
            void pinger();
            void createHospitalManager();
            void hospitalManager();
            void main();

V. Testing: (For each test case, you must show)
    + How to test
        To run the simulation you need 7 separate windows. Now in these windows
        run the following commands. Order is not important.
            > ./nachos -rs <seed> -m 0 -x ../test/disthosp 
            > ./nachos -rs <seed> -m 1 -x ../test/disthosp
            > ./nachos -rs <seed> -m 2 -x ../test/disthosp
            > ./nachos -rs <seed> -m 3 -x ../test/disthosp
            > ./nachos -rs <seed> -m 4 -x ../test/disthosp
            > ./nachos -rs <seed> -m 5 -x ../test/disthosp
            > ./nachos -rs <seed> -m 6 -x ../test/disthosp

        * You also have to make sure that a configuration file as described
          above has been placed in the current directory.
        * It may take a moment for nachos to setup and start. Be patient. :)

    + Test Output
        The above commands would start the hospital simulation and each screen
        would have the output as expected. The screens would give the outputs for the
        patients, receptionists, doorboys, doctors, cashiers and pharmacy clerks
        respectively. The output is too large to be displayed here.

VI. Discussion:
    + Experiment expectation.
        Each of the agents(Patient, Doctor, Receptionist, Cashier, Clerk
        and Hospital Manager) have been implemented properly. Their
        interactions have been appropriately synchronized and there are
        no race conditions.
                    
    + Experiment result.
        The simulation performed as expected for any given value of -rs. In
        addition, in order to enable easy tracability of the interactions
        the verbosity of the threads has been kept high, with almost all
        interactions being logged to standard output.

    + Explanation
        As the the expectation and the results match, we conclude that
        the hospital simulation has been properly implemented.

VII. Miscellaneous:
    When compiling our user programs in the test directory, use make, not gmake
    (still use gmake everywhere else).

