Title: Writeup for Project 2, Fall 2009

Date: 09/23/2009

Group Num 11: Name              Email               Student ID
              Ankur Chauhan     ankurcha@usc.edu    8478-1604-85
              Max Pflueger      pflueger@usc.edu    5888-2249-87
              Aneesha Mathew    aneesham@usc.edu    3976-3694-15

 vim:textwidth=75

I. Requirements:
    + Part 1:

    + Part 2:

II. Assumptions:

    We assume:

III. Design:

    Part 1:
        
        The system calls have been implemented as they were described in the
        student documentation. Synchronization of the lockTable, Condition variables
        Table and the process table has been delt with by using the Locks internally
        and this aspect is made transparent to the user.

        LockId CreateLock(name)
            This system call is used to create a new Lock. Each lock, as it is
            created is entered into the LocksTable and then the lock is referenced using
            the lockId as returned by this function. In case of a failure in the creation
            of the lock or failure to import the lock into the lockTable the system call
            would return -1 as the lockId.

        Acquire(LockId)
            This system call is used to acquire a lock that had been created by
            the user. In case the lock does not exist, this system call would just ignore
            the error, print out a message, "unable to find lock...".  Release(LockId) This
            system call is used to release a lock that is currently acquired by the thread.
            In case, the lock is not in the lockTable or if the lock is not currently
            acquired by the thread, the error is printed on the screen when in debug mode.

        Release(LockId)
            This used 

        DestroyLock(LockId)
            This system call is used to delete the lock which had been
            previously created. In case there are other threads in the waiting queue, the
            lock is simply marked for deletion, the actual deletion would then happen all
            the threads have left the queue and the last thread also performs the release.
            At this point it will check if it is the only thread on the queue and the lock
            is marked for deleting, it will remove the lock from the lockTable and also
            delete the Lock from memory.

        CVId CreateCondition(name)
            This system call is used to create a new Condition Variable. Each condition
            variable, as it is created is entered into the condition variables table -
            CVTable and then the condition variable is referenced using the CVId as
            returned by this call. In case of failure in the creation of the condition
            variable or failure to import the CV to the CVTable the system call returns -1.
        
        Wait(CVId, LockId)
            This is used to call Wait on a condition variable using the lock that is given
            as the second argument to this call. In case of any errors, either the lock is
            non existant or CVId is invalid or the lock used with the CVId is not the one
            for which the CV is being used or the Lock is not currently held by the current
            Thread, the program/kernel doesn't halt, instead it just displays the error and
            simply returns.

        Signal(CVId, LockId)
            This signal is used to send a signal to a condition Variable referenced using
            CVId. All the error conditions are same as that for Wait system call. It causes
            a single thread waiting on the condition variable to wake up.

        Broadcast(CVId, LockId)
            This system call is same as signal but instead of waking up just one thread
            waiting on the condition variable, it wakes up all the threads that are waiting
            on the condition variable. The error conditions are same as that mentioned for
            Wait() system call and are ignored and execution continues.

        Fork(VoidFunctionPtr)
            This system call is used to fork a new thread. When we call this function we
            get the virtual address of the function to be forked from the machine
            register(2). Then we first make a new thread. And we make the address space
            pointer point to the same address space as that of the spawning process. We
            then fork the kernel_thread function with the virtual address of the function
            to initialize the registers and allocate a new stack. This call also creates
            the required entries to the process table and the childThreads table of the
            address space associated with this thread.

        kernel_thread()
            This is a helper function for the fork system call. It does the following steps:
                1. Load the Reg with virtual address.
                2. Load the Next Reg with virtual address + 4
                3. Restore the CPU state of a user program;
                4. increment the number of user stacks for currentThread i.e.increment the process by 1
                5. Load the stack register with the stack address of new stack;
                6. Start the CPU so that it starts  running the user program thread;
        
        Exec(char *filename)
            This system call is used to create a new process. The new process which is
            created is like the one in fork but it has its own address space rather than
            sharing the address space with the spawning thread. The system call copies the
            code of the executable from the file specified by the argument and enters the
            entry into both the process table and the new address space's childThreads
            table. This system call then forks the proces  with exec_thread which then
            initializes the different registers and prepares the process to run.

        exec_thread()
            This is a helper function similar to kernel_thread(). This function takes the
            following steps: 
                1. Initialize the register by using currentThread->space.
                2. Call Restore State through currentThread->space.
                3. Call machine->Run() 

        Exit()
            This system call prepares the thread to exit properly. This funtion has the following steps
                if this is the last process in the system
                    Call Halt interrupt.
                if this is the last thread of the process but not the last process in the system
                    Clear the entry corresponding to this object from bitmap of Process tables.
                    Remove entries form process table and childThreads table.
                    Exit the current thread.
                if this is just another process neither the last nor the end of the system
                    Remove entry from the child process table and the theads table.
                    Exit current Thread.

        Yield()
            Yield causes the current thread to give up the CPU.

    Part 2:
        
        The AddrSpace class has been redesigned to accomidate multiple
        processes and multiple threads within a process.  We allow for multiple
        processes by decoupling a page's virtual address from its physical
        address.  We maintain a global BitMap corresponding to all physical
        pages of memory and associate them with virtual pages as they are
        needed.  To create multiple threads the AddrSpace must allocate stack
        space for each thread.  We do this through the InitStack and ClearStack
        methods. AddrSpace doles out stack space starting at the largest
        address, so the virtual address space will look like this:

          Virtual Address Space
                  +-------------------+ 0
                  | code              |
                  +-------------------+
                  | init data         |
                  +-------------------+
                  | uninit data       |
                  +-------------------+
                  |                   |
                  | ... unused ...    |
                  |                   |
                  +-------------------+
                  | stack 2           |
                  +-------------------+
                  | stack 1           |
                  +-------------------+
                  | stack 0           |
                  +-------------------+ 0xffff...

        AddrSpace {
            int InitStack()

                Allocates memory for a new stack in this address space, sets
                the stack register to the bottom of the stack, and returns the
                id of the stack.  The id is necessary later to be able to clear
                the stack.

            void ClearStack(int id)

                Deallocates the memory associated with the passed stack id.
                The stack is marked as cleared so the virtual address can be
                reused for a new stack of a new thread.

        }

    Part 3:
        

IV. Implementation:

    + Files Modified
        userprog/addrspace.cc
        userprog/addrspace.h
        userprog/syscall.h
        userprog/exception.cc
        threads/thread.h
        threads/thread.cc
        threads/system.h
        threads/system.cc

    + Files added
        test/acquire.c
        test/createcv.c
        test/destroycv.c
        test/destroylock.c
        test/exec.c
        test/exectest.c
        test/fork.c
        test/halt.c
        test/itoa.c
        test/lockcreate.c
        test/print.c
        test/printtest.c

    + Data Structures added, and the file they were added to.
        userprog/system.h
            struct ProcessTable
        userprog/exception.cc
            struct LockWrapper
            struct ConditionWrapper
            
    + Data Structures modified, and the file they were added to.
        class AddrSpace{
            Data Added:
                Table locksTable;
                Table CVTable;   
                set<PID> childThreads;
                Lock *childLock;
                Lock* stackTableLock;
                BitMap* stackTable;
        }

        threads/thread.h
            class Thread{
                Data Added:
                    int PID;                           
                    int stackID;                     
            }

                
            
    + Functions added and in which file.
        

    + Functions modified and in which file.
        
V. Testing: (For each test case, you must show)
    + How to test

     -Test Case 1: Testing Creation of a Lock
      In this case a lock is created and assigned to a variable.
      The value of the variable is checked to be either valid
      or invalid.
    
      How to run in nachos:
      %userprog/nachos -x ../test/lockcreate
      
      
     -Test Case 2: Testing Destroy of a Lock
      In this case a lock is created and Destroyed If the lock
      is valid we again call a destroy.
    
      How to run in nachos:
      %userprog/nachos -d + -x ../test/destroylock | grep lock

      
     -Test Case 3: Testing Acquire of a Lock
      In this case a lock is created and Acquired.The debug
      version enables us to observe the System Call Acquire.
    
      How to run in nachos:
      %userprog/nachos -d + -x ../test/acquire | grep Acquire 
      
      
     -Test Case 4: Testing Create of a Condition Variable
      In this case a CV is created and assigned to a variable.
      The value of the variable is checked to be either valid
      or invalid.
    
      How to run in nachos:
      %userprog/nachos -x ../test/createcv  

  
     -Test Case 5: Testing Destroy of a CV
      In this case a CV is created and Destroyed If the CV
      is valid we again call a destroy.
    
      How to run in nachos:
      %userprog/nachos -d + -x ../test/destroycv | grep CV









    + Test Output
      
      -Test Case 1: Testing Creation of a Lock
       OUTPUT:
       Testing lock creation...Pass
       Testing lock creamain: Exit status: 0
       
       Here we see that lock created is valid.
       Thus the Lock Creation was Successful.
       
       
      -Test Case 2: Testing Destroy of a Lock
       OUTPUT:
       main: DestroyLock_Syscall: Successfully deleted lock 0 .
       main: DestroyLock_Syscall: Unable to find lock 0 for deletion.
       
       Here we observe that after the deletion of the Lock when
       another Destroy is called it states it is unable to
       find the lock.

       
      -Test Case 3: Testing Acquire of a Lock
       OUTPUT:
       main: Lock 0: AcquireLock_Syscall.

       The System Call Acquire is being Called.


      -Test Case 4: Testing Create of a Condition Variable
       OUTPUT:
       Testing CV creation...Pass
       Testing CV creatimain: Exit status: 0

       Here we see that CV created is valid.
       Thus the CV Creation was Successful.


      -Test Case 5: Testing Destroy of a Condition Variable
       OUTPUT:     
       main : DestroyCondition_Syscall: Successfully deleted CV 0 .
       main: DestroyCondition_Syscall: Unable to find CV 0 for deletion.
      
       Here we observe that after the deletion of the CV when
       another Destroy is called it states it is unable to
       find the CV.


VI. Discussion:
    + Experiment expectation.  
            
    + Experiment result.
        
    + Explanation

VII. Miscellaneous:
